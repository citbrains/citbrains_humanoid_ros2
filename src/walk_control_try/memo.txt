tfってなんか遅そう(要確認)だし非同期だし使わない方が良いのではないか
↑これらに関連するが、そもそもうちのロボットの歩行制御での時間要件を知る必要がある。
余裕があるなら楽出来る仕組みを使うべきだし無いならそのままの実装いくしかない。
↓下読め


・まず案として*******歩行の所はもうライブラリとして歩行ノードはそれを使うAPIにしてしまう*****方が良いのでは？歩行の中身は隠ぺいして戦略やHPLStatusUIから投げられるコマンドのみを
pubsub等のros2準拠の通信方式で行うのが良さそうという感じがある。
ジョシュア先輩はeepromの読み取りをパラメータサーバから行っていたが面倒なので普通に既存の方法で良くないか、その際に使ってないやつは消す作業だけはして
歩行は歩行計算を行う際に関してのみは通信はしていない。ただグローバル変数をやりとりしているだけっぽい。
このグローバル変数のやり取りはどうするべきなんだ？これをros2のプロセス間通信にする事は一応出来るけどそれをする意味があるのかが微妙な所。
ros2にした場合恐らく同一プロセスなので共有メモリで情報のやり取りが行われるだろうけど、pubsubにした所で可読性が上がるかは微妙だし何ならグローバル変数の方が早そう。
可読性を上げるという意味なら普通にコマンド関連をリファクタする方が良い結果になる気がする。上手くやれば外部との結合はより少なくなりそうだし、リファクタリングがしやすく
なればいつかhrの息の根止められそうだしこれでも十分そうな感じ。


joystickどうなってるんだこれは。雰囲気的にはHPLのjoystick.cppを使っていそうな感じがするけど、main.cppの中ではjoy.cが普通に動いて読み取っている感じがある。





オドメトリはcalc_mv.cでやってるぽいです...




データのやり取り

はじめコマンド
・ここに関しては普通にtopic通信で良いのでは。serviceという手もあるが微妙そう
IMU 
・IMUのライブラリでセンサー値を読んでいるが、これをそのままmain関数の中で行うのは適当なのか？
なるべく疎結合にするにはセンサを読み取るノードで流した方が良い？
でもそれこそQueueにたまったセンサデータの扱い良く分からんし、非同期だからいつ読み取ったかも分からんからどうなんだ？？


サーボの指令っぽい所
serv.cの一番上のxv_servo_rs.goal_position辺りが怪しい。これは同じスコープ内のxv_sv.deg_dlimから値を代入されているようだ。
恐らくこの辺で指令をもらっているんではないか
↑xv_svに対してはどっかで見たxv_refが値を渡している。













入出力


はじめコマンド(モーション等)
普通にsubする。



IMU
現在main.cpp内でRTIMURibを使ってimuのデータ取得を行っている部分を独立したセンサノードにする。そこからAttitude Filterノードにpub。
現在のmain.cppに値するノードでそれをsubする。



オドメトリ
joy.c内のsfmtに情報を書き込んで通信している。ここを単純にpubするだけ。



サーボへの角度指令
サーボへの指令を行うノードを作る。
実機での運用時はsubした角度指令をb3m.cppのWrite_Servo_B3M_All_2Kport()で扱える形に変換しサーボに送る。webots等のシミュレータで動かす際は受け取った値をwebots
のロボットへの角度指令としてpub。




vision 
HPLstatusUI での色塗りをどうにかする。
白線のプロセス間通信をどうにかする。それかchainerの所どうにかする。
現状visionはHPLのAPIを通して利用しているがそれをどうするか。


visionのサブモジュールの構成を把握する
現在の使われ方



























servo_rs_func()でモーション毎の補正等をしてからサーボに書き込みをしているので、
ジョシュア先輩の方法では多分モーション再生は厳しいはず。
だから補正後のをpubしたいがどうしようかな。
今の様に環境変数でやるのは最悪。コマンドライン引数でやるか？
オーバーライド出来ないしなぁ。クラス作るか